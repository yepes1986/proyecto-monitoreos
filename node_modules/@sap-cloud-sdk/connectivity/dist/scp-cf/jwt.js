"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTenantIdFromBinding = exports.decodeOrMakeJwt = exports.isUserToken = exports.getJwtPair = exports.isXsuaaToken = exports.wrapJwtInHeader = exports.verificationKeyCache = exports.verifyJwt = exports.retrieveJwt = exports.decodeJwtComplete = exports.decodeJwt = exports.audiences = exports.getSubdomain = exports.getTenantId = exports.getDefaultTenantId = exports.userId = exports.defaultTenantId = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const xssec_1 = require("@sap/xssec");
const jsonwebtoken_1 = require("jsonwebtoken");
const cache_1 = require("./cache");
const environment_accessor_1 = require("./environment-accessor");
const subdomain_replacer_1 = require("./subdomain-replacer");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'jwt'
});
/**
 * @internal
 */
exports.defaultTenantId = 'provider-tenant';
function makeArray(val) {
    return val ? (Array.isArray(val) ? val : [val]) : [];
}
/**
 * @internal
 * Get the user ID from the JWT payload.
 * @param jwtPayload - Token payload to read the user ID from.
 * @returns The user ID, if available.
 */
function userId({ user_id }) {
    logger.debug(`JWT user_id is: ${user_id}.`);
    return user_id;
}
exports.userId = userId;
/**
 * @internal
 * Get the default tenant ID.
 * @returns The default tenant ID.
 */
function getDefaultTenantId() {
    logger.debug('Could not determine tenant from JWT nor XSUAA, identity or destination service binding. Client Credentials token is cached without tenant information.');
    return exports.defaultTenantId;
}
exports.getDefaultTenantId = getDefaultTenantId;
/**
 * Get the tenant ID of a decoded JWT, based on its `zid` or if not available `app_tid` property.
 * @param jwt - Token to read the tenant ID from.
 * @returns The tenant ID, if available.
 */
function getTenantId(jwt) {
    const decodedJwt = jwt ? decodeJwt(jwt) : {};
    logger.debug(`JWT zid is: ${decodedJwt.zid}, app_tid is: ${decodedJwt.app_tid}.`);
    return decodedJwt.zid || decodedJwt.app_tid || undefined;
}
exports.getTenantId = getTenantId;
/**
 * @internal
 * Retrieve the subdomain from the decoded XSUAA JWT. If the JWT is not in XSUAA format, returns `undefined`.
 * @param jwt - JWT to retrieve the subdomain from.
 * @returns The subdomain, if available.
 */
function getSubdomain(jwt) {
    const decodedJwt = jwt ? decodeJwt(jwt) : {};
    return (decodedJwt?.ext_attr?.zdn ||
        (isXsuaaToken(decodedJwt) ? (0, subdomain_replacer_1.getIssuerSubdomain)(decodedJwt) : undefined));
}
exports.getSubdomain = getSubdomain;
/**
 * @internal
 * Retrieve the audiences of a decoded JWT based on the audiences and scopes in the token.
 * @param decodedToken - Token to retrieve the audiences from.
 * @returns A set of audiences.
 */
// Comments taken from the Java SDK implementation
// Currently, scopes containing dots are allowed.
// Since the UAA builds audiences by taking the substring of scopes up to the last dot,
// scopes with dots will lead to an incorrect audience which is worked around here.
// If a JWT contains no audience, infer audiences based on the scope names in the JWT.
// This is currently necessary as the UAA does not correctly fill the audience in the user token flow.
function audiences(decodedToken) {
    const parsedAudiences = audiencesFromAud(decodedToken);
    return parsedAudiences.length
        ? parsedAudiences
        : audiencesFromScope(decodedToken);
}
exports.audiences = audiences;
function audiencesFromAud({ aud }) {
    return makeArray(aud).map(audience => audience.split('.')[0]);
}
function audiencesFromScope({ scope }) {
    return makeArray(scope).reduce((aud, s) => (s.includes('.') ? [...aud, s.split('.')[0]] : aud), []);
}
/**
 * Decode JWT.
 * @param token - JWT to be decoded.
 * @returns Decoded payload.
 */
function decodeJwt(token) {
    return typeof token === 'string' ? decodeJwtComplete(token).payload : token;
}
exports.decodeJwt = decodeJwt;
/**
 * Decode JWT and return the complete decoded token.
 * @param token - JWT to be decoded.
 * @returns Decoded token containing payload, header and signature.
 * @internal
 */
function decodeJwtComplete(token) {
    const decodedToken = (0, jsonwebtoken_1.decode)(token, { complete: true, json: true });
    if (decodedToken !== null && isJwtWithPayloadObject(decodedToken)) {
        return decodedToken;
    }
    throw new Error('JwtError: The given jwt payload does not encode valid JSON.');
}
exports.decodeJwtComplete = decodeJwtComplete;
/**
 * Retrieve JWT from a request that is based on the node `IncomingMessage`. Fails if no authorization header is given or has the wrong format. Expected format is 'Bearer <TOKEN>'.
 * @param req - Request to retrieve the JWT from.
 * @returns JWT found in header.
 */
function retrieveJwt(req) {
    const authHeader = getAuthHeader(req);
    if (validateAuthHeader(authHeader)) {
        return authHeader?.split(' ')[1];
    }
}
exports.retrieveJwt = retrieveJwt;
function getAuthHeader(req) {
    const authHeader = (0, util_1.pickValueIgnoreCase)(req.headers, 'authorization');
    if (authHeader) {
        return Array.isArray(authHeader) ? authHeader[0] : authHeader;
    }
}
function validateAuthHeader(header) {
    if (typeof header === 'undefined') {
        logger.warn('Authorization header not set.');
        return false;
    }
    const [authType, token] = header.split(' ');
    if (typeof token === 'undefined') {
        logger.warn('Token in auth header missing.');
        return false;
    }
    if (authType.toLowerCase() !== 'bearer') {
        logger.warn('Authorization type is not Bearer.');
        return false;
    }
    return true;
}
/**
 * Verifies the given JWT and returns the decoded payload.
 * @param jwt - JWT to be verified
 * @param options - Options to control certain aspects of JWT verification behavior.
 * @returns A Promise to the decoded and verified JWT.
 * @internal
 */
async function verifyJwt(jwt, options) {
    const disableCache = !{ ...defaultVerifyJwtOptions, ...options }
        .cacheVerificationKeys;
    const xsuaaService = (0, environment_accessor_1.getXsuaaService)({ disableCache, jwt });
    const { token } = await (0, xssec_1.createSecurityContext)(xsuaaService, {
        jwt
    }).catch(e => {
        throw new util_1.ErrorWithCause('Failed to verify JWT.', e);
    });
    return token.payload;
}
exports.verifyJwt = verifyJwt;
const defaultVerifyJwtOptions = {
    cacheVerificationKeys: true
};
/**
 * 15 minutes is the default value used by the xssec lib.
 * @internal
 */
exports.verificationKeyCache = new cache_1.Cache(900000);
/**
 * Wraps the access token in header's authorization.
 * @param token - Token to attach in request header
 * @returns The request header that holds the access token
 * @internal
 */
function wrapJwtInHeader(token) {
    return { headers: { Authorization: 'Bearer ' + token } };
}
exports.wrapJwtInHeader = wrapJwtInHeader;
/**
 * Checks if the given JWT was issued by XSUAA based on the `iss` property and the UAA domain of the XSUAA.
 * @param decodedJwt - JWT to be checked.
 * @returns Whether the JWT was issued by XSUAA.
 * @internal
 */
function isXsuaaToken(decodedJwt) {
    return decodedJwt?.ext_attr?.enhancer === 'XSUAA';
}
exports.isXsuaaToken = isXsuaaToken;
/**
 * Build JwtPair from an encoded JWT.
 * @internal
 */
function getJwtPair(encodedJwt) {
    return { encoded: encodedJwt, decoded: decodeJwt(encodedJwt) };
}
exports.getJwtPair = getJwtPair;
/**
 * The user JWT can be a full JWT containing user information but also a reduced one setting only the iss value
 * This method divides the two cases.
 * @param token - Token to be investigated
 * @returns Boolean value with true if the input is a UserJwtPair
 * @internal
 */
function isUserToken(token) {
    if (!token) {
        return false;
    }
    // Check if it is an Issuer Payload
    const keys = Object.keys(token.decoded);
    return !(keys.length === 1 && keys[0] === 'iss');
}
exports.isUserToken = isUserToken;
function isJwtWithPayloadObject(decoded) {
    return typeof decoded.payload !== 'string';
}
/**
 * This method either decodes the given JWT or tries to retrieve the tenant from a service binding (XSUAA, IAS or destination) as `zid`.
 * @param options - Options passed to register the destination containing the JWT.
 * @returns The decoded JWT or a dummy JWT containing the tenant identifier (zid).
 * @internal
 */
function decodeOrMakeJwt(jwt) {
    if (jwt) {
        const decodedJwt = typeof jwt === 'string' ? decodeJwt(jwt) : jwt;
        if (getTenantId(decodedJwt)) {
            return decodedJwt;
        }
    }
    const providerTenantId = getTenantIdFromBinding();
    // This is returning a JWT with an XSUAA style zid.
    // It might make sense to check whether the binding was IAS and then rather return app_tid, as it would be in a IAS token.
    if (providerTenantId) {
        return { zid: providerTenantId };
    }
}
exports.decodeOrMakeJwt = decodeOrMakeJwt;
/**
 * @internal
 * @returns The tenant identifier from the XSUAA, identity or destination service binding.
 */
function getTenantIdFromBinding() {
    return ((0, environment_accessor_1.getServiceCredentials)('xsuaa')?.tenantid ||
        (0, environment_accessor_1.getServiceCredentials)('identity')?.app_tid ||
        (0, environment_accessor_1.getServiceCredentials)('destination')?.tenantid);
}
exports.getTenantIdFromBinding = getTenantIdFromBinding;
//# sourceMappingURL=jwt.js.map