"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformServiceBindingToDestination = exports.serviceToDestinationTransformers = void 0;
const token_accessor_1 = require("../token-accessor");
const jwt_1 = require("../jwt");
/**
 * @internal
 */
exports.serviceToDestinationTransformers = {
    'business-logging': businessLoggingBindingToDestination,
    's4-hana-cloud': xfS4hanaCloudBindingToDestination,
    destination: destinationBindingToDestination,
    'saas-registry': saasRegistryBindingToDestination,
    workflow: workflowBindingToDestination,
    'service-manager': serviceManagerBindingToDestination,
    xsuaa: xsuaaToDestination,
    aicore: aicoreToDestination
};
/**
 * Convenience function to create a destination from the provided service binding.
 * If a JWT is provided as part of options, the tenant in the JWT is used for client credentials grant, else the provider tenant is used, wherever applicable.
 * Supported service types are:
 * - business-logging (OAuth2ClientCredentials)
 * - destination (OAuth2ClientCredentials)
 * - s4-hana-cloud (BasicAuthentication)
 * - saas-registry (OAuth2ClientCredentials)
 * - workflow (OAuth2ClientCredentials)
 * - service-manager (OAuth2ClientCredentials)
 * - xsuaa (OAuth2ClientCredentials)
 * - aicore (OAuth2ClientCredentials)
 * Throws an error if the provided service binding is not supported.
 * @param serviceBinding - The service binding to transform.
 * @param options - Options used for fetching the destination.
 * @returns A promise returning the transformed destination on success.
 */
async function transformServiceBindingToDestination(serviceBinding, options) {
    if (exports.serviceToDestinationTransformers[serviceBinding.label]) {
        return exports.serviceToDestinationTransformers[serviceBinding.label](serviceBinding, options);
    }
    throw new Error(`The provided service binding of type ${serviceBinding.label} is not supported out of the box for destination transformation.`);
}
exports.transformServiceBindingToDestination = transformServiceBindingToDestination;
async function aicoreToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildClientCredentialsDestination(token, service.credentials.serviceurls.AI_API_URL, service.name);
}
async function xsuaaToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildClientCredentialsDestination(token, service.credentials.apiurl, service.name);
}
async function serviceManagerBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildClientCredentialsDestination(token, service.credentials.sm_url, service.name);
}
async function destinationBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildClientCredentialsDestination(token, service.credentials.uri, service.name);
}
async function saasRegistryBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildClientCredentialsDestination(token, service.credentials['saas_registry_url'], service.name);
}
async function businessLoggingBindingToDestination(service, options) {
    const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
    };
    const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
    return buildClientCredentialsDestination(token, service.credentials.writeUrl, service.name);
}
async function workflowBindingToDestination(service, options) {
    const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
    };
    const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
    return buildClientCredentialsDestination(token, service.credentials.endpoints.workflow_odata_url, service.name);
}
async function xfS4hanaCloudBindingToDestination(service) {
    return {
        url: service.credentials.URL,
        authentication: 'BasicAuthentication',
        username: service.credentials.User,
        password: service.credentials.Password
    };
}
function buildClientCredentialsDestination(token, url, name) {
    const expirationTime = (0, jwt_1.decodeJwt)(token).exp;
    const expiresIn = expirationTime
        ? Math.floor((expirationTime * 1000 - Date.now()) / 1000).toString(10)
        : undefined;
    return {
        url,
        name,
        authentication: 'OAuth2ClientCredentials',
        authTokens: [
            {
                value: token,
                type: 'bearer',
                expiresIn,
                http_header: { key: 'Authorization', value: `Bearer ${token}` },
                error: null
            }
        ]
    };
}
//# sourceMappingURL=service-binding-to-destination.js.map