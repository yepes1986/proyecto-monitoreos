export = IdentityService;
/**
 * This {@link Service} class is constructed from SAP Identity Service credentials to provide an API with selected functionality against that service instance, e.g. token validation and token fetches.
 */
declare class IdentityService extends Service {
    /**
     * Returns an issuer URL based on the issuer of the token if it can be succesfully validated against a list of trusted domains.
     * @param {IdentityServiceToken} token token from which issuer is extracted
     * @param {Array<string>} trustedDomains a list of trusted domains
     * @returns {String} URL of issuer if its domain is either a trusted domain or a subdomain of a trusted domain
     * @throws {UntrustedIssuerError} if issuer is empty, not trusted or not a valid URL
     */
    static getSafeUrlFromTokenIssuer: (token: IdentityServiceToken, trustedDomains?: Array<string>) => string;
    /**
     * Validates that the client owning the given certificate is the owner of the token.
     * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
     * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
     * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
     * @param {IdentityServiceToken} token
     * @param {X509Certificate} cert client certificate parsed as X509Certificate
     */
    static validateTokenOwnership(token: IdentityServiceToken, cert: X509Certificate): void;
    /**
     * @param {Types.ServiceCredentials & Types.IdentityServiceCredentials} credentials
     * @param {Types.ServiceConfig & Types.IdentityServiceConfig} [serviceConfiguration={}]
     */
    constructor(credentials: Types.ServiceCredentials & Types.IdentityServiceCredentials, serviceConfiguration?: Types.ServiceConfig & Types.IdentityServiceConfig);
    /**
     * @override
     * @param {String|IdentityServiceToken} token token as JWT or IdentityServiceToken object
     * @param {Types.SecurityContextConfig} contextConfig
     * @returns {Promise<IdentityServiceSecurityContext>}
     */
    override createSecurityContext(token: string | IdentityServiceToken, contextConfig?: Types.SecurityContextConfig): Promise<IdentityServiceSecurityContext>;
    /**
     * @override
     * @param {IdentityServiceToken} token
     * @param {Types.SecurityContextConfig} contextConfig
     */
    override validateToken(token: IdentityServiceToken, contextConfig: Types.SecurityContextConfig): Promise<void>;
    fetchJwks({ clientid, app_tid, azp, clientCertificatePem }: {
        clientid: any;
        app_tid: any;
        azp: any;
        clientCertificatePem: any;
    }, { correlationId, extractHeaders }: {
        correlationId: any;
        extractHeaders: any;
    }): Promise<any>;
    /**
     * Fetches a token from this service with this service's client credentials.
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse>}
     */
    fetchClientCredentialsToken(options?: Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions): Promise<Types.TokenFetchResponse>;
    /**
     * Fetches a user token from this service with the given username and password.
     * @param {String} username
     * @param {String} password
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>}
     */
    fetchPasswordToken(username: string, password: string, options?: Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions): Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>;
    /**
     * Fetches a JWT bearer token from this service with the given user token as assertion.
     * @param {String} assertion JWT bearer token used as assertion
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>}
     */
    fetchJwtBearerToken(assertion: string, options?: Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions): Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>;
    /** @override */
    override buildTokenRequest(grant_type: any, options: any): {
        method: string;
        body: URLSearchParams;
    };
    /**
     * @override
     * @inheritdoc
     */
    override getTokenUrl(grant_type: any, options?: {}): Promise<URL>;
    /**
     * Returns whether proof token validation has been enabled via the service's configuration.
     * @returns {Boolean}
     */
    hasProofTokenEnabled(): boolean;
    /**
     * Returns whether x5t proof of token ownership validation has been enabled via the service's configuration.
     * @returns {Boolean}
     */
    hasX5tEnabled(): boolean;
    #private;
}
declare namespace IdentityService {
    export { X509Certificate };
}
import Service = require("./Service");
import IdentityServiceToken = require("../token/IdentityServiceToken");
import Types = require("../util/Types");
import IdentityServiceSecurityContext = require("../context/IdentityServiceSecurityContext");
type X509Certificate = import("crypto").X509Certificate;
//# sourceMappingURL=IdentityService.d.ts.map