export = Service;
/**
 * @typedef {import('../token/Token')} Token
 * @typedef {import('../context/SecurityContext')} SecurityContext
 * @typedef {import('../jwks/Jwks')} Jwks
 * @typedef {import('../error/validation/ValidationError')} ValidationError
 */
declare class Service {
    static "__#4@#sharedJwksCaches": {};
    /**
     * Builds the configuration of this service based on the provided configuration and default values.
     * @param {Types.ServiceConfig} serviceConfiguration
     */
    static buildServiceConfiguration(config: any): any;
    /**
     *
     * @param {Types.ServiceCredentials} credentials
     * @param {Types.ServiceConfig} [serviceConfiguration={}]
     */
    constructor(credentials: Types.ServiceCredentials, serviceConfiguration?: Types.ServiceConfig);
    /** @type {Types.ServiceCredentials} */
    credentials: Types.ServiceCredentials;
    endpoints: {
        oidc_info: string;
    };
    config: any;
    oidcCache: ResponseCache;
    jwksCache: any;
    /**
     * Checks if this service is the recipient of the given token.
     * @param {Token} token
     * @returns {Boolean}
     */
    acceptsTokenAudience(token: Token): boolean;
    /**
     * Called internally to validate the credentials to have the necessary properties before performing a specific action, e.g. token fetch.
     *
     * @internal
     * @param {string} action description of action for which the credentials are being validated.
     * @param {...string} mandatoryProperties mandatory properties that must be present in the credentials.
     * @throws {InvalidCredentialsError} if any of the mandatory properties are missing in the credentials.
     */
    validateCredentials(action: string, ...mandatoryProperties: string[]): void;
    /**
     * Checks if the given token is valid under the given contextConfig.
     * @param {Token} token
     * @param {Types.SecurityContextConfig} contextConfig
     * @throws {ValidationError} if the token is not valid or could not be validated
    */
    validateToken(token: Token, contextConfig: Types.SecurityContextConfig): Promise<void>;
    /**
     * Checks if the given token's signature is valid under the given contextConfig.
     * @param {Token} token
     * @param {Types.SecurityContextConfig} contextConfig
     * @returns {Promise<void>} resolves when token signature is valid, otherwise error is thrown
     * @throws {ValidationError} if the token signature is not valid or could not be validated
     */
    validateTokenSignature(token: Token, contextConfig: Types.SecurityContextConfig): Promise<void>;
    getOpenIDConfiguration({ correlationId }?: {
        correlationId: any;
    }): Promise<any>;
    fetchOpenIDConfiguration({ correlationId }?: {
        correlationId: any;
    }): Promise<any>;
    /**
     * Fetches a token from this service with this service's client credentials.
     * @param {Types.TokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse>} response
     */
    fetchClientCredentialsToken(options?: Types.TokenFetchOptions): Promise<Types.TokenFetchResponse>;
    /**
     * Fetches a user token from this service with the given username and password.
     * @param {String} username
     * @param {String} password
     * @param {Types.TokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse>} response
     */
    fetchPasswordToken(username: string, password: string, options?: Types.TokenFetchOptions): Promise<Types.TokenFetchResponse>;
    /**
     * Fetches a JWT bearer token from this service with the given user token as assertion.
     * @param {Types.TokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse>} response
     */
    fetchJwtBearerToken(assertion: any, options?: Types.TokenFetchOptions): Promise<Types.TokenFetchResponse>;
    /**
     * @param {String} grant_type
     * @param {Types.TokenFetchOptions} options
     */
    buildTokenRequest(grant_type: string, options: Types.TokenFetchOptions): {
        method: string;
        body: URLSearchParams;
    };
    /**
     * Prepares the given request to use this service's client credentials for authentication.
     * Adds clientid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
     * @param {RequestInit} request
     * @param {URLSearchParams} request.body
     * @param {Types.TokenFetchOptions} options
     */
    addClientAuthentication(request: RequestInit, options?: Types.TokenFetchOptions): void;
    /**
     * Creates a new {@link SecurityContext} from this service with the given token.
     * @abstract
     * @param {String|Token} token as JWT or Token object
     * @param {Types.SecurityContextConfig} contextConfig
     * @returns {Promise<SecurityContext>} securityContext
     */
    createSecurityContext(token: string | Token, contextConfig?: Types.SecurityContextConfig): Promise<SecurityContext>;
    /**
     * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
     *
     * @param {string} token the token for which to retrieve the JWKS.
     * @param {Types.SecurityContextConfig} contextConfig the context configuration object.
     * @returns {Promise<Jwks>} A promise that resolves to the JWKS (JSON Web Key Set) object.
     * @throws {Error} If an error occurs while retrieving the JWKS.
     */
    getJwks(token: string, contextConfig: Types.SecurityContextConfig): Promise<Jwks>;
    /**
     * Determines the URL that can be used for fetching tokens of given grant_type from this service.
     * @abstract
     * @param {Types.GrantType} grant_type
     * @param {Object} options
     * @param {String} options.correlationId
     * @returns {Promise<URL>} URL of the service's token endpoint
     */
    getTokenUrl(grant_type: Types.GrantType, options?: {
        correlationId: string;
    }): Promise<URL>;
    #private;
}
declare namespace Service {
    export { Token, SecurityContext, Jwks, ValidationError };
}
import Types = require("../util/Types");
import ResponseCache = require("../cache/ResponseCache");
type Token = import("../token/Token");
type SecurityContext = import("../context/SecurityContext");
type Jwks = import("../jwks/Jwks");
type ValidationError = import("../error/validation/ValidationError");
//# sourceMappingURL=Service.d.ts.map