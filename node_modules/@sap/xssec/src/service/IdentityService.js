'use strict';

/**
 * @typedef {import("crypto").X509Certificate} X509Certificate
 */

const Service = require('./Service');
const SecurityContext = require('../context/SecurityContext');
const IdentityServiceSecurityContext = require('../context/IdentityServiceSecurityContext');
const IdentityServiceToken = require('../token/IdentityServiceToken');
const Jwks = require('../jwks/Jwks');
const InvalidCredentialsError = require('../error/configuration/InvalidCredentialsError');
const { MissingClientCertificateError, MissingIssuerError, InvalidIssuerError, UntrustedIssuerError, X5tError, ConfigurationError, ResponseError, WrongAudienceError } = require('../error');
const util = require('../util/util');
const { createCacheKey, escapeStringForRegex } = require('../util/util');
const { jsonRequest } = require('../util/request');
const { getLogger } = require('../util/logging');
const { APP_TID_HEADER, AZP_HEADER, CLIENT_CERTIFICATE_HEADER, CLIENTID_HEADER, HTTPS_SCHEME, SERVICE_PLAN_HEADER, X5T_CNF_CLAIM } = require('../util/constants');
const Types = require("../util/Types");

const LOG = getLogger("IdentityService.js");

/**
 * This {@link Service} class is constructed from SAP Identity Service credentials to provide an API with selected functionality against that service instance, e.g. token validation and token fetches.
 */
class IdentityService extends Service {

    /**
     * @param {Types.ServiceCredentials & Types.IdentityServiceCredentials} credentials 
     * @param {Types.ServiceConfig & Types.IdentityServiceConfig} [serviceConfiguration={}]
     */
    constructor(credentials, serviceConfiguration) {
        super(credentials, serviceConfiguration);
    }

    /**
     * @override
     * @param {String|IdentityServiceToken} token token as JWT or IdentityServiceToken object
     * @param {Types.SecurityContextConfig} contextConfig 
     * @returns {Promise<IdentityServiceSecurityContext>}
     */
    async createSecurityContext(token, contextConfig = {}) {
        if (typeof token === "string") token = new IdentityServiceToken(token);
        SecurityContext.buildContextConfig(contextConfig);

        if (this.#proofTokenCheckRequired(token) || this.hasX5tEnabled()) {
            if (contextConfig.clientCertificatePem == null) {
                throw new MissingClientCertificateError();
            } else {
                contextConfig.clientCertificate = util.parsePemCertificate(contextConfig.clientCertificatePem);
            }
        }

        // cast generic token and validate
        const iasToken = new IdentityServiceToken(token.jwt, { header: token.header, payload: token.payload });
        await this.validateToken(iasToken, contextConfig);

        const ctx = new IdentityServiceSecurityContext(this, iasToken, contextConfig);
        for (let extension of this.config.context?.extensions || []) {
            await extension.extendSecurityContext(ctx);
        }
        return ctx;
    }

    /**
     * @override
     * @param {IdentityServiceToken} token 
     * @param {Types.SecurityContextConfig} contextConfig 
     */
    async validateToken(token, contextConfig) {
        if (this.hasX5tEnabled()) {
            IdentityService.validateTokenOwnership(token, contextConfig.clientCertificate);
        }

        // expiration time, audience, signature etc.
        await super.validateToken(token, contextConfig);
    }    

    /**
     * Retrieves the JWKS (JSON Web Key Set) for the given token and context configuration.
     * 
     * @param {string} token - The token for which to retrieve the JWKS.
     * @param {Types.SecurityContextConfig} contextConfig - The context configuration object.
     * @returns {Promise<Jwks>} - A promise that resolves to the JWKS (JSON Web Key Set) object.
     * @throws {WrongAudienceError} - if the online validation in the JWKS endpoint of the Identity Service instance responds with a 400 status code, indicating that the token should not be accepted by this service.
     * @throws {Error} - If an error occurs while retrieving the JWKS.
     */
    async getJwks(token, contextConfig) {
        this.validateCredentials("fetch JWKS", "clientid", "url");

        // throws for malicious issuers
        const issuerUrl = IdentityService.getSafeUrlFromTokenIssuer(token, this.credentials.domains);
        
        const jwksParams = {
            clientid: this.credentials.clientid,
            app_tid: token.appTid,
            azp: token.azp
        }
        const keyParts = { url: issuerUrl, ...jwksParams };
        
        const proofTokenCheck = this.#proofTokenCheckRequired(token);
        if (proofTokenCheck) {
            keyParts.certSub = contextConfig.clientCertificate?.subject;
            jwksParams.clientCertificatePem = contextConfig.clientCertificatePem?.replaceAll("\\n", "").replaceAll("\n", "");
        }

        const cacheKey = createCacheKey(keyParts);

        const buildJwksRequest = () => {
            // fetch JWKS either from this service if it has issued the token, or if not, from the trusted issuer service using this service's client id
            const issuerService = issuerUrl === this.credentials.url ? this : new IdentityService({ url: issuerUrl, clientid: this.credentials.clientid });
            const extractHeaders = proofTokenCheck ? "headers" : null;

            return async (correlationId) => {
                const jwksResponse = await issuerService.fetchJwks(jwksParams, { correlationId, extractHeaders });

                return {
                    jwks: new Jwks(jwksResponse.keys),
                    servicePlans: proofTokenCheck ? jwksResponse.headers.get(SERVICE_PLAN_HEADER)?.split(",").map(plan => plan.replaceAll("\\\"", "")) : null
                };
            }
        }

        let cachedResponse;
        try {
            cachedResponse = await this.jwksCache.getOrRequest(cacheKey, buildJwksRequest, { correlationId: contextConfig.correlationId });
        } catch(error) {
            if (error instanceof ResponseError && error.responseCode === 400 && error.request.name === `${this.constructor.name}.fetchJwks`) {
                /**
                 * Online validation in JWKS endpoint may have negative result for the provided header / query parameters.
                 * In this case, the response will have status 400 and should result in a WrongAudienceError instead of a (subclass of) NetworkError.
                 */
                throw new WrongAudienceError(token, this, `The online validation in the JWKS endpoint of the Identity Service instance responded with 400: '${error.responseText}'. This indicates that the token should not be accepted by this service.`);

            } 
        
            throw error;
        }

        const { jwks, servicePlans } = cachedResponse;
        if (proofTokenCheck) {
            contextConfig.servicePlans = servicePlans;
        }

        return jwks;
    }   

    async fetchJwks({ clientid, app_tid, azp, clientCertificatePem }, { correlationId, extractHeaders }) {
        const openIDConfiguration = await this.getOpenIDConfiguration(correlationId);
        const jwksUrl = openIDConfiguration.jwks_uri;

        const options = {
            method: 'GET',
            headers: {
                [CLIENTID_HEADER]: clientid
            }
        };

        if(app_tid != null) {
            options.headers[APP_TID_HEADER] = app_tid;
        }

        if(azp != null) {
            options.headers[AZP_HEADER] = azp;
        }            

        if (clientCertificatePem != null) {
            options.headers[CLIENT_CERTIFICATE_HEADER] = clientCertificatePem
        }

        return jsonRequest(jwksUrl, options, { requestName: `${this.constructor.name}.fetchJwks`, correlationId, extractHeaders });
    }

    // Re-declare JSDoc for token fetches with detailed options and return object properties

    /**
     * Fetches a token from this service with this service's client credentials.
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options
     * @returns {Promise<Types.TokenFetchResponse>}
     */
    async fetchClientCredentialsToken(options = {}) {
        return super.fetchClientCredentialsToken(options);
    }

    /**
     * Fetches a user token from this service with the given username and password.
     * @param {String} username
     * @param {String} password
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options      
     * @returns {Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>}
     */
    async fetchPasswordToken(username, password, options = {}) {
        return super.fetchPasswordToken(username, password, options);
    }

    /**
     * Fetches a JWT bearer token from this service with the given user token as assertion.
     * @param {String} assertion JWT bearer token used as assertion   
     * @param {Types.TokenFetchOptions & Types.IdentityServiceTokenFetchOptions} options      
     * @returns {Promise<Types.TokenFetchResponse & Types.IdTokenFetchResponse & Types.RefreshableTokenFetchResponse>}
     */
    async fetchJwtBearerToken(assertion, options = {}) {
        return super.fetchJwtBearerToken(assertion, options);
    }

    /** @override */
    buildTokenRequest(grant_type, options) {
        const request = super.buildTokenRequest(grant_type, options);

        if (options.resource) {
            // multiple resources need to be listed explicitly with multiple resource=<resource> key-value-pairs
            [options.resource]
                .flatMap(r => r)
                .forEach(resource => request.body.append("resource", resource));
        }

        return request;
    }

    /**
     * Prepares the given formData and fetch options to use this service's client credentials for authentication.
     * Adds clientid, app_tid and either clientsecret or an mTLS agent based on client certificate, depending on the type of credentials.
     * @param {RequestInit} request 
     * @param {URLSearchParams} request.body
     * @param {Types.TokenFetchOptions} options
     * @override
     */
    addClientAuthentication(request, options = {}) {
        super.addClientAuthentication(request, options);

        const app_tid = options.app_tid ?? this.credentials.app_tid;
        if(app_tid != null) {
            request.body.append("app_tid", app_tid);
        }
    }

    /**
     * @override
     * @inheritdoc
     */
    async getTokenUrl(grant_type, options = {}) {
        const { correlationId } = options;
        const openidConfiguration = await this.getOpenIDConfiguration({ correlationId });

        if (!openidConfiguration.grant_types_supported.includes(grant_type)) {
            throw new ConfigurationError(`This Identity Service instance does not support grant type ${grant_type} according to its openid-configuration.`);
        }

        return new URL(openidConfiguration.token_endpoint);
    }

    /** 
     * Returns whether proof token validation has been enabled via the service's configuration.
     * @returns {Boolean}
     */
    hasProofTokenEnabled() {
        return this.config.validation?.proofToken?.enabled;
    }

    /** 
     * Returns whether x5t proof of token ownership validation has been enabled via the service's configuration.
     * @returns {Boolean}
     */
    hasX5tEnabled() {
        return this.config.validation?.x5t?.enabled;
    }

    /**
     * Returns whether a proof token check has to be done for the given token.
     * The decision depends on the type of token.
     * Tokens with claim ias_api are App2App tokens for which a proof token check must not be done, even when enabled via the configuration.
     * @param {IdentityServiceToken} token 
     */
    #proofTokenCheckRequired(token) {
        return this.hasProofTokenEnabled() && token.payload.ias_apis == null;
    }

    /**
     * Returns an issuer URL based on the issuer of the token if it can be succesfully validated against a list of trusted domains.
     * @param {IdentityServiceToken} token token from which issuer is extracted
     * @param {Array<string>} trustedDomains a list of trusted domains
     * @returns {String} URL of issuer if its domain is either a trusted domain or a subdomain of a trusted domain
     * @throws {UntrustedIssuerError} if issuer is empty, not trusted or not a valid URL
     */
    static getSafeUrlFromTokenIssuer = function (token, trustedDomains = []) {
        const issuer = token?.issuer;
        if (!issuer) {
            throw new MissingIssuerError(token);
        }

        const issuerUrl = issuer.startsWith(HTTPS_SCHEME) ? issuer : `${HTTPS_SCHEME}${issuer}`;
        try {
            new URL(issuerUrl);
        } catch (e) {
            throw new InvalidIssuerError(token, e);
        }

        const issuerDomain = issuerUrl.substring(HTTPS_SCHEME.length);
        for (let d of trustedDomains) {
            const validSubdomainPattern = `^[a-zA-Z0-9-]{1,63}\\.${escapeStringForRegex(d)}$`; // a string that ends with .<trustedDomain> and contains 1-63 letters, digits or '-' before that for the subdomain
            if (issuerDomain === d || issuerDomain.match(new RegExp(validSubdomainPattern))) {
                return issuerUrl;
            }
        }

        throw new UntrustedIssuerError(token);
    }

    /**
     * Validates that the client owning the given certificate is the owner of the token.
     * The validation is based on proof-of-posession via certificate binding of tokens as described in {@link https://datatracker.ietf.org/doc/html/rfc8705 RFC 8705}.
     * The validation is succesful if the token contains an base64url-encoded x5t thumbprint under claim {@link CNF_X5T_CLAIM cnf.x5t#S256} that matches the given certificate.
     * The client certificate against which the validation is performed, is typically extracted from the {@link FWD_CLIENT_CERT_HEADER x-forwarded-client-cert} request header where it is put by BTP after TLS termination.
     * @param {IdentityServiceToken} token 
     * @param {X509Certificate} cert client certificate parsed as X509Certificate
     */
    static validateTokenOwnership(token, cert) {
        const tokenX5t = token.payload.cnf?.[X5T_CNF_CLAIM];
        if (!tokenX5t) {
            throw new X5tError(token, cert, "X5t validation failed because x5t thumbprint could not be found in token.");
        }

        let certificateX5t;
        try {
            certificateX5t = Buffer.from(cert.fingerprint256.replaceAll(":", ""), "hex").toString("base64url");
        } catch (e) {
            throw new X5tError(token, cert, "x5t validation failed because x5t thumbprint could not be calculated from client certificate.");
        }

        if (tokenX5t !== certificateX5t) {
            throw new X5tError(token, cert, "x5t thumbprint did not match the thumbprint of the provided client certificate.");
        }
    }
}


module.exports = IdentityService;