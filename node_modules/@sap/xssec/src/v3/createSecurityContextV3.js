const createSecurityContext = require("../context/createSecurityContext");
const ConfigurationError = require("../error/configuration/ConfigurationError");
const { getLogger } = require('../util/logging');
const XsuaaService = require("../service/XsuaaService");
const IdentityService = require("../service/IdentityService");
const UaaService = require("../service/IdentityService");
const createServiceFromCredentials = require("./createService");
const ValidationError = require("../error/validation/ValidationError");
const XsaService = require("../service/XsaService");
const Types = require("../util/Types");

/**
 * @typedef {import("../context/SecurityContext")} SecurityContext
 * @typedef {import("../token/Token")} Token
 */

const LOG = getLogger("createSecurityContextV3.js");

/**
 * @callback createSecurityContextV3Callback
 * @param {Error} error
 * @param {SecurityContext} xssec3SecurityContext
 * @param {Token} xssec3TokenInfo
 */

/**
 * 
 * @param {String} jwt 
 * @param {Object} configParameter 
 * @param {boolean|createSecurityContextV3Callback} forceType 
 * @param {createSecurityContextV3Callback} cb 
 */
async function createSecurityContextV3(jwt, configParameter, forceType, cb) {
    if (typeof forceType === 'function') {
        cb = forceType;
        forceType = null;
    }

    if (cb == null || typeof cb !== 'function') {
        throw new ConfigurationError("The callback parameter must be a function.");
    }

    try {
        if (configParameter == null) {
            throw new ConfigurationError("The configParameter parameter must not be null or undefined.");
        } else if (jwt == null) {
            throw new ConfigurationError("The jwt parameter must not be null or undefined.");
        }

        const contextConfig = buildContextConfig(configParameter, jwt);
        const serviceConfig = buildServiceConfig(configParameter);
        const services = buildServices(contextConfig.credentials, forceType, serviceConfig);
        const securityContext = await createSecurityContext(services, contextConfig);

        return cb(null, securityContext, securityContext.token);
    } catch (error) {
        if (error instanceof ValidationError) {
            cb(error, null, { isValid: () => false, getErrorObject: () => error });
        }

        return cb(error);
    }
}

/**
 * Build new contextConfig structure based on old configParameter structure, which can have options potentially located inside credentials
 * @param {Object} configParameter 
 * @param {String} jwt 
 * @returns {Types.SecurityContextConfig}
 */
function buildContextConfig(configParameter, jwt) {
    // if configParameter has no credentials property, assume it is a credentials object or array itself
    const contextConfig = configParameter.credentials ? configParameter : { credentials: configParameter };

    contextConfig.jwt = jwt;
    contextConfig.correlationId ??= contextConfig.credentials.correlationId;
    contextConfig.clientCertificatePem ??= contextConfig.x509Certificate ?? contextConfig.credentials.x509Certificate;

    return contextConfig;
}

/**
 * Build new serviceConfig structure based on old configParameter structure, which can have options potentially located inside credentials
 * @param {Object} configParameter 
 * @returns {Types.ServiceConfig}
 */
function buildServiceConfig(configParameter) {
    const serviceConfig = {};

    serviceConfig.validation ??= {};
    serviceConfig.validation.x5t ??= {};
    serviceConfig.validation.x5t.enabled ??= configParameter.x5tValidation;
    serviceConfig.validation.jwks ??= {};
    serviceConfig.validation.jwks.cache ??= {};
    Object.assign(serviceConfig.validation.jwks.cache, configParameter.jwksCache);
    serviceConfig.validation.jwks.shared = true; // use the same JWKS cache for subsequent calls to createSecurityContextV3, otherwise EACH request will fetch the JWKS again
    serviceConfig.validation.jwks.cache.disabled = configParameter.disableCache;

    return serviceConfig;
}

/**
 * Build service objects based on credentials and forceType
 * @param {Array} credentials 
 * @param {boolean} forceType 
 * @param {Types.ServiceConfig} serviceConfig 
 * @returns {Service[]}
 */
function buildServices(credentials, forceType, serviceConfig) {
    const credentialsArray = Array.isArray(credentials) ? credentials : [credentials];
    insertXsAppnameFromEnv(credentialsArray);

    if (forceType) {
        LOG.info(`forceType === ${forceType}. Creating ${forceType} service(s) from credentials.`);
    }

    switch (forceType) {
        case "XSUAA":
            return credentialsArray.map(c => new XsuaaService(c, serviceConfig));
        case "XSA":
            return credentialsArray.map(c => new XsaService(c, serviceConfig));
        case "IAS":
            return credentialsArray.map(c => new IdentityService(c, serviceConfig));
        case "UAA":
            return credentialsArray.map(c => new UaaService(c, serviceConfig));
        case null:
        case undefined:
        default:
            return credentialsArray.map(c => createServiceFromCredentials(c, serviceConfig));
    }
}

/**
 * Backward-compatible filling of xsappname in credentials with environment variable XSAPPNAME if present.
 * @param {Array} credentials 
 */
function insertXsAppnameFromEnv(credentials) {
    if (process.env.XSAPPNAME) {
        for (const c of credentials) {
            c.xsappname = process.env.XSAPPNAME;
        }
    }
}

module.exports = createSecurityContextV3;